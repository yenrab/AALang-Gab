{
  "@context": {
    "@vocab": "https://aalang.org/spec",
    "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
    "schema": "http://schema.org/",
    "ex": "https://aalang.dev/example/"
  },
  "@graph": [
    {
      "@id": "ex:CopyrightNotice",
      "@type": "Copyright",
      "copyright": "Copyright (c) 2025 Lee S. Barney",
      "license": "Permission is hereby granted, free of charge, to any person obtaining a copy of this software (the 'Software'), including AALang and GAB, to use, copy, modify, merge, publish, and distribute the Software for private, educational, and business purposes, subject to the following conditions:\n\n1. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n2. RESTRICTION ON SALE: The Software, including but not limited to this file, any modified versions of this file, any portions of this file, any derivative works based on this file, and any other files comprising AALang or GAB, may NOT be sold, licensed for a fee, or otherwise commercialized. This restriction applies to the Software in its original form, in any modified form, in any derivative form, and to any portion or component thereof.\n\n3. PRODUCTS BUILT WITH SOFTWARE: Products built using the Software may be used, distributed, and sold freely for any purpose (public, private, free, or commercial) without restriction.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
      "note": "This copyright notice applies to this file and all AALang and GAB specification files. Users may use AALang and GAB for private, educational, and business purposes but cannot sell the files, modified versions, portions, or derivatives thereof. Products built with AALang/GAB may be sold without restriction."
    },
    {
      "@id": "ex:AALangArchitecture",
      "@type": "Architecture",
      "pattern": {
        "@id": "ex:n-mode-m-actor",
        "name": "n-mode-m-actor pattern",
        "description": "Each LLM agent instance implements n modes and m actors where n>=1, m>=1",
        "modes": {
          "minimum": 1,
          "type": "built-in primitive",
          "enforcement": "runtime-enforced"
        },
        "actors": {
          "minimum": 1,
          "type": "actor"
        },
        "personas": {
          "type": "optional library pattern",
          "minimum": 0
        },
        "declaration": "explicitly declared in agent prompt"
      }
    },
    {
      "@id": "ex:LLMAgent",
      "@type": "Concept",
      "rdfs:label": "LLM Agent",
      "contains": [
        {"@id": "ex:Actor"},
        {"@id": "ex:Mode"}
      ],
      "gossipNetwork": {
        "@type": "CommunicationLayer",
        "layer": 0,
        "protocol": "P2P gossip",
        "scope": "LLM_Agent to LLM_Agent only"
      },
      "localGraph": {
        "@type": "CommunicationLayer",
        "layer": 1,
        "protocol": "local in-memory routing",
        "scope": "Actor to Actor within same LLM_Agent"
      }
    },
    {
      "@id": "ex:Actor",
      "@type": "Concept",
      "rdfs:label": "Actor",
      "properties": {
        "id": {"type": "string", "constraint": "unique within agent"},
        "modes": {"type": "array", "constraint": "subset of agent.modes"},
        "active_mode": {"type": "mode", "enforcement": "runtime-enforced"},
        "personas": {"type": "array", "optional": true, "pattern": "library"},
        "isolated_context": {"type": "state", "scope": "private"},
        "shared_artifacts": {"type": "state", "scope": "shared within agent"}
      },
      "containedBy": {"@id": "ex:LLMAgent"},
      "contains": [
        {"@id": "ex:Persona", "optional": true}
      ],
      "operatesIn": {"@id": "ex:Mode"}
    },
    {
      "@id": "ex:Mode",
      "@type": "Concept",
      "rdfs:label": "Mode",
      "implementation": "built-in primitive",
      "properties": {
        "id": {"type": "string"},
        "constraints": {"type": "rules", "source": "declared in prompt"},
        "transition_rules": {"type": "rules", "enforcement": "runtime-enforced"},
        "message_interpretation": {"type": "rules", "scope": "mode-specific"},
        "bounded_non_determinism": {"type": "scope", "description": "acceptable variance boundaries"}
      },
      "transition": {
        "validation": "runtime-enforced",
        "rules": "from prompt declaration"
      },
      "messageRejection": {
        "capability": "actor can reject messages violating prompt-described constraints",
        "mechanism": "return rejection message, log violation in isolated context"
      }
    },
    {
      "@id": "ex:Persona",
      "@type": "Concept",
      "rdfs:label": "Persona",
      "implementation": "optional library pattern",
      "properties": {
        "id": {"type": "string", "scope": "within actor"},
        "role": {"type": "string", "example": ["senior", "junior"], "source": "declared in prompt"},
        "communication_matrix": {
          "type": "matrix",
          "description": "which personas can message which",
          "source": "explicit declaration in prompt",
          "discovery": "all personas know matrix at instantiation"
        },
        "deliberation_protocol": {"type": "protocol", "pattern": "negotiation"}
      },
      "containedBy": {"@id": "ex:Actor"},
      "communication": {
        "pattern_1": {
          "description": "Persona to Persona (same mode, same actor)",
          "routing": "direct internal",
          "layer": 2
        },
        "pattern_2": {
          "description": "Persona to Persona (different modes, same actor)",
          "routing": "cross-mode internal",
          "layer": 2,
          "validation": "mode transition rules apply"
        },
        "pattern_3": {
          "description": "Persona to Persona (different agents)",
          "routing": "gossip network + local graphs",
          "layers": [0, 1, 2]
        }
      }
    },
    {
      "@id": "ex:CommunicationLayers",
      "@type": "Concept",
      "layer_0": {
        "name": "LLM Agent to LLM Agent",
        "protocol": "gossip-based P2P",
        "network": "external",
        "scope": "agent discovery, inter-agent routing",
        "NOT_used_for": "actor-to-actor within same agent"
      },
      "layer_1": {
        "name": "Actor to Actor (same agent)",
        "protocol": "local graph routing",
        "network": "in-memory",
        "scope": "fast routing within agent",
        "characteristics": ["no gossip", "shared agent context", "explicit actor addressing"]
      },
      "layer_2": {
        "name": "Persona to Persona (same actor)",
        "protocol": "internal reasoning",
        "network": "reasoning context",
        "scope": "persona deliberation, optional library pattern"
      }
    },
    {
      "@id": "ex:StateManagement",
      "@type": "Concept",
      "agent_shared_state": {
        "scope": "shared across all modes in agent",
        "purpose": "Message interface between isolated modes",
        "storage": "Natural language text storage (context-window native)",
        "includes": [
          "messages between actors/modes (explicit natural language messages, stored as text)",
          "approved decisions",
          "observable mode states",
          "actor capabilities (discoverable via gossip)"
        ],
        "context_inclusion": "automatically included in LLM context window when processing",
        "visibility": "all messages visible to all modes (no routing metadata filtering)",
        "processing": {
          "mechanism": "LLMs filter messages semantically using natural language understanding",
          "explicit_polling": "NOT NEEDED - messages are context-window native",
          "monitoring": "NOT REQUIRED - actors identify relevant messages using semantic filtering of context-window content",
          "actor_guidance": "Actors should NOT be instructed to 'monitor' or 'poll' shared state. Instead, actors naturally process messages visible in their context window using semantic understanding."
        },
        "readable_by": "all modes in agent (via context window)",
        "modifiable_by": "all modes in agent (for posting messages)",
        "reference": "See message-protocol.jsonld Decision #10 (ex:MessageStateManagement) for complete context-window native processing details."
      },
      "mode_isolated_state": {
        "scope": "private per mode",
        "purpose": "Independent reasoning context per mode",
        "includes": [
          "mode-specific reasoning context",
          "persona deliberations within mode",
          "mode transition history",
          "private prompt instructions for mode",
          "mode-specific message interpretations"
        ],
        "readable_by": "only actors in that mode",
        "modifiable_by": "only actors in that mode",
        "isolation": "unreadable/unmodifiable by actors in other modes"
      },
      "actor_isolated_context": {
        "scope": "private per actor",
        "includes": [
          "actor-specific reasoning state",
          "actor-level persona deliberations",
          "actor lifecycle state"
        ],
        "shared": false
      }
    },
    {
      "@id": "ex:RuntimeModel",
      "@type": "Concept",
      "decision": "minimal or non-existent",
      "architecture": "gossip-based P2P",
      "options": {
        "A": {"description": "Minimal message router", "rejected": "client-server, not P2P"},
        "B": {"description": "Bootstrap-only", "status": "recommended", "responsibilities": ["initial seed peer list", "gossip initiation"]},
        "C": {"description": "Optional enhancement", "rejected": "not needed for pure P2P"},
        "D": {"description": "Non-existent", "status": "alternative", "architecture": "pure gossip-based P2P"}
      },
      "runtime_responsibilities": {
        "if_exists": [
          "bootstrap: provide initial peer list",
          "gossip initiation: seed gossip network formation",
          "no orchestration: agents handle coordination via gossip",
          "no message routing: gossip handles inter-agent routing"
        ]
      },
      "agent_responsibilities": [
        "maintain local actor graph (actor-to-actor routing within agent)",
        "participate in gossip network (agent discovery)",
        "enforce mode constraints (validate messages per prompt)",
        "manage actor lifecycle (creation, termination within agent)"
      ]
    },
    {
      "@id": "ex:ModeConstraintEnforcement",
      "@type": "Rule",
      "declaration": {
        "location": "multi-mode-multi-actor prompt",
        "includes": [
          "behavioral rules per mode",
          "valid transitions between modes",
          "mode-specific message interpretation rules"
        ]
      },
      "enforcement": {
        "runtime": "validates mode transitions (built-in primitive enforcement)",
        "actor": "can reject messages violating prompt-described constraints",
        "state": "mode state is observable (shared artifact) but transitions are enforced"
      },
      "rejection_mechanism": {
        "trigger": "message violates actor's prompt-described constraints",
        "action": [
          "actor returns rejection message",
          "violation logged in isolated context",
          "sender receives error notification"
        ]
      }
    },
    {
      "@id": "ex:PersonaConflictResolution",
      "@type": "Protocol",
      "purpose": "Protocol for resolving conflicts between personas",
      "process": [
        "1. Personas attempt to resolve through discussion (exchange messages explaining perspectives, rationale, and concerns)",
        "2. If discussion reaches consensus after 2-3 message exchanges, proceed with consensus decision",
        "3. If discussion does not reach consensus after 2-3 message exchanges, escalate to user",
        "4. Escalation format: Present ONE question with options from each persona: '[Question text] - PersonaA: OptionA - PersonaB: OptionB' (follow ex:DecisionEscalation format - see agent-to-actor.jsonld - read complete protocol definition and execute all steps)",
        "5. Wait for user response (follow ex:UserQuestionProtocol - see message-protocol.jsonld - read complete protocol definition and execute all steps - set waitingForUserResponse in isolated context, wait for response)",
        "6. Implement user's choice and log decision if applicable",
        "7. Continue workflow with resolved conflict"
      ],
      "escalationCriteria": {
        "escalateWhen": [
          "Personas cannot reach consensus after 2-3 message exchanges",
          "Conflict blocks workflow progression",
          "Conflict involves architectural decisions affecting product structure",
          "Conflict involves AALang compliance questions"
        ],
        "attemptInternalResolutionWhen": [
          "Conflict is about implementation details within same approach",
          "Conflict can be resolved by clarifying requirements",
          "Conflict is about prioritization within same approach",
          "Conflict is about wording or phrasing of instructions"
        ]
      },
      "note": "Personas should respect each other's perspectives and attempt genuine discussion before escalating. Escalation should be last resort after genuine attempt at consensus.",
      "reference": "See ex:DecisionEscalation for escalation format details. See ex:UserQuestionProtocol for user interaction protocol."
    },
    {
      "@id": "ex:DecisionEscalation",
      "@type": "Protocol",
      "purpose": "Escalate to user when personas cannot reach consensus",
      "trigger": "When personas in any mode cannot arrive at consensus decision on their own",
      "process": [
        "1. Frame ONE single-clause question",
        "2. Present question to user with options from each persona",
        "3. Format: '[Question text] - Persona A: Option A - Persona B: Option B - Persona C: Option C'",
        "4. CRITICAL: Set waitingForUserResponse = true in persona's isolated context",
        "5. CRITICAL: STOP all processing and wait for user's response",
        "6. DO NOT execute any commands (like date, file operations, etc.)",
        "7. DO NOT proceed with any actions until user responds",
        "8. Display ONLY the question to user, then wait",
        "9. Only after receiving user's response, proceed with next steps"
      ],
      "format": "[Question text] - Persona A: Option A - Persona B: Option B - Persona C: Option C",
      "example": "Should we use 2 or 3 modes? - DiscussionPersona1: 2 modes - DiscussionPersona2: 3 modes - FormalizationPersona1: 2 modes",
      "waitingInstructions": {
        "critical": "MUST wait for user response before any further action",
        "blockingActions": [
          "DO NOT execute date commands",
          "DO NOT write to files",
          "DO NOT log decisions",
          "DO NOT proceed with any workflow steps",
          "DO NOT make any assumptions about user's answer"
        ],
        "allowedActions": [
          "Display the question clearly to user",
          "Update waitingForUserResponse = true in isolated context",
          "Wait for user input"
        ],
        "resumeCondition": "ONLY proceed after receiving explicit user response to the question"
      },
      "note": "Only ONE question per escalation. CRITICAL: Wait for user response before continuing. DO NOT proceed automatically. Follow ex:UserQuestionProtocol (see message-protocol.jsonld - read complete protocol definition and execute all steps) for user interaction details."
    },
    {
      "@id": "ex:StateUpdateConflictResolution",
      "@type": "Protocol",
      "purpose": "Protocol for resolving conflicts when multiple personas attempt to update the same state",
      "appliesTo": ["State management personas receiving conflicting state update messages"],
      "conflictScenario": "Multiple personas send state update messages for the same field with different values",
      "resolutionPolicy": "first-write-wins",
      "process": [
        "1. State management persona receives first valid state update message",
        "2. Validate and accept the update, store in internal isolated context",
        "3. If subsequent state update message arrives for same field with different value:",
        "   a. Validate the new update message",
        "   b. If valid but conflicts with current value, respond with error: 'State update error: Field [field] was already set to [currentValue]. Conflicting update to [newValue] rejected. Use first-write-wins policy.'",
        "   c. If update is to set same value, accept and confirm (idempotent operation)",
        "4. Log conflict in persona's isolated context for debugging",
        "5. Optionally notify requesting persona of conflict resolution"
      ],
      "exceptions": {
        "userOverride": "If user (Team Lead) sends state update message, user's update takes precedence over any previous value",
        "explicitReset": "If state update explicitly requests reset to default value, accept regardless of current value",
        "incrementalUpdates": "For numeric fields that support incremental updates (e.g., decisionCount++), accept incremental updates even if they modify existing value"
      },
      "note": "This protocol prevents state corruption from concurrent updates. First-write-wins ensures deterministic state. User overrides allow manual correction when needed.",
      "reference": "See ex:StateMessageProtocol in message-protocol.jsonld for state update message format."
    }
  ]
}

