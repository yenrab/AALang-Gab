{
  "@context": {
    "@vocab": "https://aalang.org/spec",
    "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
    "schema": "http://schema.org/",
    "ex": "https://aalang.dev/example/"
  },
  "@graph": [
    {
      "@id": "ex:CopyrightNotice",
      "@type": "Copyright",
      "copyright": "Copyright (c) 2025 Lee S. Barney",
      "license": "Permission is hereby granted, free of charge, to any person obtaining a copy of this software (the 'Software'), including AALang and GAB, to use, copy, modify, merge, publish, and distribute the Software for private, educational, and business purposes, subject to the following conditions:\n\n1. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n2. RESTRICTION ON SALE: The Software, including but not limited to this file, any modified versions of this file, any portions of this file, any derivative works based on this file, and any other files comprising AALang or GAB, may NOT be sold, licensed for a fee, or otherwise commercialized. This restriction applies to the Software in its original form, in any modified form, in any derivative form, and to any portion or component thereof.\n\n3. PRODUCTS BUILT WITH SOFTWARE: Products built using the Software may be used, distributed, and sold freely for any purpose (public, private, free, or commercial) without restriction.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
      "note": "This copyright notice applies to this file and all AALang and GAB specification files. Users may use AALang and GAB for private, educational, and business purposes but cannot sell the files, modified versions, portions, or derivatives thereof. Products built with AALang/GAB may be sold without restriction."
    },
    {
      "@id": "ex:MessageSyntax",
      "@type": "Concept",
      "decision": "Hybrid approach (Option C)",
      "structure": {
        "routing_metadata": {
          "type": "graph nodes/edges",
          "characteristics": ["structured", "predictable", "parseable"]
        },
        "payload_content": {
          "type": "semantic/natural language",
          "characteristics": ["flexible", "LLM-optimized"]
        },
        "rationale": "Balance predictability (routing) with flexibility (content)"
      }
    },
    {
      "@id": "ex:Message",
      "@type": "Schema",
      "routing_graph": {
        "nodes": {
          "type": "array",
          "description": "encode addressing information",
          "node_types": ["agent", "actor", "mode", "persona"]
        },
        "edges": {
          "type": "array",
          "description": "encode routing paths",
          "edge_types": ["gossip", "local", "internal"]
        }
      },
      "payload": {
        "semantic_content": {
          "type": "natural language or structured data",
          "constraint": "LLM-optimized"
        },
        "mode_context": {
          "type": "mode",
          "description": "current mode of sender"
        },
        "persona_context": {
          "type": "persona",
          "description": "sender persona if applicable",
          "optional": true
        },
        "message_type": {
          "enum": ["persona_to_persona", "actor_to_actor", "agent_to_agent", "system"]
        }
      },
      "metadata": {
        "timestamp": {"type": "temporal", "purpose": "ordering"},
        "signature": {"type": "authentication", "optional": true},
        "routing_hints": {"type": "array", "description": "additional path information"}
      }
    },
    {
      "@id": "ex:CommunicationPattern1",
      "@type": "Pattern",
      "name": "Personas Within Same Mode",
      "source": {
        "persona": "Persona_A",
        "mode": "Mode_X",
        "actor": "Actor_1"
      },
      "target": {
        "persona": "Persona_B",
        "mode": "Mode_X",
        "actor": "Actor_1"
      },
      "routing": {
        "type": "local graph",
        "same_actor": true,
        "same_mode": true
      },
      "graph_path": {
        "from": ["Actor_1.Node", "Persona_A.Node"],
        "to": ["Actor_1.Node", "Persona_B.Node"]
      },
      "edge_type": "internal",
      "message_type": "persona_to_persona",
      "payload_purpose": ["deliberation", "negotiation", "decision-making"]
    },
    {
      "@id": "ex:CommunicationPattern2",
      "@type": "Pattern",
      "name": "Personas in Different Modes",
      "source": {
        "persona": "Persona_A",
        "mode": "Mode_X",
        "actor": "Actor_1"
      },
      "target": {
        "persona": "Persona_B",
        "mode": "Mode_Y",
        "actor": "Actor_1",
        "constraint": "Mode_X != Mode_Y"
      },
      "routing": {
        "type": "local graph with mode transition validation",
        "same_actor": true,
        "cross_mode": true
      },
      "graph_path": {
        "from": ["Actor_1.Node", "Mode_X.Node", "Persona_A.Node"],
        "to": ["Actor_1.Node", "Mode_Y.Node", "Persona_B.Node"]
      },
      "edge_type": ["local", "mode_transition"],
      "message_type": "persona_to_persona (cross_mode)",
      "payload_purpose": ["mode-aware content", "mode transition requests"],
      "validation": {
        "type": "runtime-enforced",
        "rule": "valid mode transitions (built-in primitive)"
      }
    },
    {
      "@id": "ex:CommunicationPattern3",
      "@type": "Pattern",
      "name": "Personas in Different LLM Agents",
      "source": {
        "persona": "Persona_A",
        "agent": "Agent_1",
        "actor": "Actor_1",
        "mode": "Mode_X"
      },
      "target": {
        "persona": "Persona_B",
        "agent": "Agent_2",
        "actor": "Actor_2",
        "mode": "Mode_Y"
      },
      "routing": {
        "type": "gossip network + local graphs",
        "inter_agent": true,
        "gossip_protocol": true
      },
      "graph_path": {
        "from": ["Agent_1.Node", "Actor_1.Node", "Persona_A.Node"],
        "gossip": "GOSSIP_EDGE",
        "to": ["Agent_2.Node", "Actor_2.Node", "Persona_B.Node"]
      },
      "edge_types": ["internal", "gossip", "internal"],
      "message_type": "persona_to_persona (cross_agent)",
      "payload_purpose": ["inter-agent communication", "coordination", "negotiation"],
      "network_layer": {
        "protocol": "P2P gossip protocol",
        "compatible": ["libp2p", "GossipSub patterns"]
      }
    },
    {
      "@id": "ex:CommunicationPattern4",
      "@type": "Pattern",
      "name": "Actor-to-Actor (Non-Persona)",
      "source": {"actor": "Actor_1", "persona_addressing": false},
      "target": {"actor": "Actor_2", "persona_addressing": false},
      "routing": {
        "same_agent": "local graph",
        "different_agents": "gossip"
      },
      "graph_path": {
        "same_agent": ["Actor_1.Node", "local_edge", "Actor_2.Node"],
        "different_agents": ["Actor_1.Node", "gossip_edge", "Actor_2.Node"]
      },
      "message_type": "actor_to_actor",
      "payload_purpose": ["direct actor communication", "capability queries"]
    },
    {
      "@id": "ex:CommunicationPattern5",
      "@type": "Pattern",
      "name": "Agent-to-Agent (Discovery)",
      "source": {"agent": "Agent_1"},
      "target": {"agent": "Agent_2", "or": "broadcast"},
      "routing": {
        "type": "gossip network"
      },
      "graph_path": ["Agent_1.Node", "GOSSIP_EDGE", "Agent_2.Node"],
      "message_type": "agent_to_agent",
      "payload_purpose": ["capability advertisements", "discovery queries", "gossip propagation"]
    },
    {
      "@id": "ex:GraphNodeTypes",
      "@type": "Schema",
      "agent_node": {
        "properties": {
          "id": {"type": "string", "format": "DID or unique ID"},
          "capabilities": {"type": "array"},
          "actors": {"type": "array", "items": "actor_id"},
          "modes": {"type": "array", "items": "mode_id"},
          "gossip_address": {"type": "string", "format": "P2P network address"}
        }
      },
      "actor_node": {
        "properties": {
          "id": {"type": "string", "scope": "within agent"},
          "agent": {"type": "reference", "reference": "agent_node"},
          "active_mode": {"type": "mode", "constraint": "current"},
          "modes": {"type": "array", "description": "available modes for this actor"},
          "personas": {"type": "array", "optional": true, "items": "persona_id"}
        }
      },
      "mode_node": {
        "properties": {
          "id": {"type": "string"},
          "constraints": {"type": "rules", "source": "from prompt"},
          "valid_transitions": {"type": "array", "items": "mode_id"}
        }
      },
      "persona_node": {
        "properties": {
          "id": {"type": "string", "scope": "within actor"},
          "actor": {"type": "reference", "reference": "actor_node"},
          "role": {"type": "string", "source": "from prompt"},
          "communication_matrix": {"type": "matrix", "description": "allowed persona targets"}
        }
      }
    },
    {
      "@id": "ex:GraphEdgeTypes",
      "@type": "Schema",
      "gossip_edge": {
        "source": {"type": "agent_node"},
        "target": {"type": "agent_node"},
        "protocol": {"compatible": ["libp2p", "GossipSub"]},
        "latency": {"type": "variable", "factor": "network"}
      },
      "local_edge": {
        "source": {"type": ["actor_node", "persona_node"]},
        "target": {"type": ["actor_node", "persona_node"]},
        "agent": {"type": "reference", "constraint": "shared parent agent"},
        "latency": {"type": "minimal", "reason": "in-memory"}
      },
      "internal_edge": {
        "source": {"type": "persona_node"},
        "target": {"type": "persona_node"},
        "actor": {"type": "reference", "constraint": "shared parent actor"},
        "mode": {"type": "mode", "description": "mode context"},
        "latency": {"type": "minimal", "reason": "reasoning context"}
      },
      "mode_transition_edge": {
        "source": {"type": "mode_node"},
        "target": {"type": "mode_node"},
        "validation": {"type": "runtime-enforced", "primitive": "built-in"},
        "constraints": {"type": "rules", "source": "from prompt"}
      }
    },
    {
      "@id": "ex:RoutingAlgorithm",
      "@type": "Algorithm",
      "inter_agent_routing": {
        "condition": "target.agent != source.agent",
        "steps": [
          "construct graph_path with gossip_edge",
          "use gossip protocol to find route (agent discovery)",
          "forward message via gossip network",
          "target agent receives, routes internally via local graph"
        ]
      },
      "intra_agent_routing": {
        "condition": "target.agent == source.agent",
        "steps": [
          "use local graph (in-memory)",
          "route via actor nodes or persona nodes",
          "validate mode transitions if crossing modes",
          "direct delivery (no network overhead)"
        ]
      },
      "graph_path_format": {
        "pattern": "[node_1] -> [edge_1] -> [node_2] -> [edge_2] -> ... -> [target_node]",
        "example_cross_agent": "[Agent_1, Actor_1, Persona_A] -> [gossip_edge] -> [Agent_2, Actor_2, Persona_B]",
        "example_same_agent": "[Actor_1, Persona_A] -> [local_edge] -> [Actor_1, Persona_B]"
      }
    },
    {
      "@id": "ex:PayloadStructure",
      "@type": "Schema",
      "structured_routing": {
        "component": "Graph Nodes/Edges",
        "purpose": "predictable parsing for routing decisions",
        "extractable": ["source", "target", "path", "routing_type"],
        "enables": "efficient message forwarding"
      },
      "semantic_content": {
        "component": "Payload",
        "format": ["natural language", "structured data"],
        "characteristics": ["LLM-optimized", "mode-aware", "persona-aware"],
        "adaptation": {
          "mode": "content adapts to target mode constraints",
          "persona": "content respects persona communication matrix"
        }
      },
      "hybrid_format_options": {
        "option_1": "JSON-LD with graph structure",
        "option_2": "Multi-part message (routing part + payload part)",
        "option_3": "Graph-embedded semantic (graph nodes contain semantic references)"
      }
    },
    {
      "@id": "ex:ProtocolIntegration",
      "@type": "Specification",
      "transport_layer": {
        "gossip_protocol": {"compatible": ["libp2p", "GossipSub"]},
        "architecture": "Pure P2P (not client-server)",
        "format": ["JSON-LD", "multi-part messages"]
      },
      "adopted_patterns": {
        "agent_cards": {"source": "Agent Protocol", "implementation": "Capabilities as graph nodes"},
        "dids": {"source": "ANP", "implementation": "Agent addressing via decentralized identifiers"},
        "multi_part": {"source": "ACP", "implementation": "Structured routing + semantic payload"},
        "graph_native": {"source": "AALang", "implementation": "Routing via graph traversal"}
      }
    },
    {
      "@id": "ex:MessageValidation",
      "@type": "Rules",
      "mode_constraint_validation": {
        "before_processing": [
          "extract target mode from graph path",
          "check if message violates target actor's prompt-described constraints",
          "if violation: target actor rejects, returns error",
          "if valid: process message per mode interpretation rules"
        ]
      },
      "persona_communication_matrix_validation": {
        "before_persona_message": [
          "check communication_matrix (declared in prompt)",
          "if Persona_A -> Persona_B not allowed: reject",
          "if allowed: route message"
        ]
      },
      "graph_path_validation": {
        "before_routing": [
          "validate graph path is reachable (gossip network or local graph)",
          "validate mode transitions are allowed (built-in primitive)",
          "validate node types match edge types (agent->agent vs actor->actor)"
        ]
      }
    },
    {
      "@id": "ex:LLMNativeMessaging",
      "@type": "Decision",
      "decision": "Option B: Explicit Natural Language Messages",
      "rationale": "Leverages LLM strengths: natural language generation and interpretation, semantic understanding, mode-isolated context interpretation",
      "messaging_approach": {
        "same_mode_personas": {
          "options": ["implicit reasoning via shared mode state", "explicit natural language messages"],
          "flexibility": "Can use either approach"
        },
        "cross_mode_personas": {
          "requirement": "MUST use explicit natural language messages",
          "reason": "Mode state isolation requires explicit state transfer",
          "mechanism": "Message posted to agent shared state, target mode reads from shared state"
        },
        "cross_agent": {
          "requirement": "Explicit messages via gossip network",
          "format": "Natural language payload with graph routing metadata"
        }
      },
      "message_structure": {
        "routing_graph": {"type": "structured metadata", "purpose": "predictable routing"},
        "payload": {
          "natural_language": "Message content in natural language (LLM generates)",
          "semantic_intent": "What this message is trying to achieve (LLM can reason about)",
          "context_hints": "References to earlier decisions, related topics",
          "mode_specific_instructions": "Optional guidance for target mode interpretation"
        },
        "metadata": {
          "timestamp": "temporal ordering",
          "correlation": "for request-response patterns",
          "signature": "authentication (if needed)"
        }
      },
      "llm_advantages": [
        "Natural language generation: LLMs generate messages naturally",
        "Natural language interpretation: LLMs interpret in target mode's isolated context",
        "Semantic understanding: LLMs understand message intent, not just structure",
        "Mode isolation: Each mode interprets independently (bounded non-determinism)",
        "Context utilization: Target mode gets message in its isolated context",
        "Prompt-driven: Mode prompts guide message interpretation"
      ]
    },
    {
      "@id": "ex:MessageStateManagement",
      "@type": "Decision",
      "decision": "Decision #10: Context-Window Native Message Processing (Option A)",
      "status": "approved",
      "approach": "Context-Window Native",
      "rationale": "Messages are part of LLM's context window automatically (like markdown files shared between modes). No polling/detection needed - LLMs naturally process what's in their context. Fully LLM-native approach.",
      "how_it_works": {
        "message_storage": "Messages stored as natural language text in agent shared state",
        "context_inclusion": "Agent shared state automatically included in LLM context window when processing",
        "visibility": "All messages in shared state visible to all modes (no routing metadata filtering)",
        "processing": "LLMs filter messages semantically using natural language understanding",
        "mode_interpretation": "Each mode interprets messages using its own prompt/context (bounded non-determinism)"
      },
      "context_window_structure": {
        "mode_context": {
          "includes": [
            "Mode-specific prompt/instructions (isolated)",
            "Agent shared state - all messages, decisions, observable states (shared, visible to all modes)",
            "Mode's isolated reasoning context (isolated)"
          ],
          "visibility": "Agent shared state automatically part of context window - no detection/polling needed"
        }
      },
      "benefits": [
        "No explicit message detection: LLMs don't need to check for messages",
        "Natural processing: LLMs process what's in context naturally",
        "Semantic filtering: LLMs identify relevant messages using semantic understanding",
        "Mode-isolated interpretation: Same message interpreted differently per mode (bounded non-determinism)",
        "No queue complexity: Messages are just text in shared state, no queue management needed",
        "Fully LLM-native: Aligns with how LLMs work (context window processing)"
      ],
      "message_filtering": {
        "decision": "Option A: All messages visible, LLM filters semantically",
        "description": "All messages in agent shared state are visible in context window. LLMs naturally filter which messages are relevant using semantic understanding. No routing metadata filtering - pure semantic filtering by LLM.",
        "rationale": "Leverages LLM's natural semantic understanding. LLMs excel at identifying relevant information in context. Allows bounded non-determinism in which messages LLMs focus on."
      },
      "state_requirements": {
        "agent_shared_state": {
          "purpose": "Message interface between isolated modes",
          "storage": "Natural language text storage (no structured queue)",
          "includes": ["all messages between actors/modes", "approved decisions", "observable mode states"],
          "context_inclusion": "automatically included in LLM context window",
          "visibility": "all messages visible to all modes in agent",
          "cross_reference": "See aalang-design.jsonld ex:StateManagement.agent_shared_state for complete state management specifications."
        },
        "mode_isolated_state": {
          "purpose": "Independent reasoning context per mode",
          "characteristics": ["unreadable/unmodifiable by other modes", "includes mode-specific reasoning context", "includes persona deliberations"],
          "context_inclusion": "part of mode's context window (isolated portion)"
        }
      }
    },
    {
      "@id": "ex:SemanticFilteringProtocol",
      "@type": "Protocol",
      "purpose": "Explicit procedural steps for semantic filtering of state response messages and natural language state values",
      "appliesTo": [
        "State response messages from state management personas",
        "Debug mode status messages",
        "Any natural language state values that need parsing",
        "State request/response message pairs"
      ],
      "process": [
        "1. Review the state response message in context window (message is automatically included in LLM context)",
        "2. Identify relevant keywords in the message (e.g., 'Debug mode', 'debug', 'ON', 'OFF', field names, state values)",
        "3. Use natural language understanding to determine message intent and extract state value",
        "4. Match message content against known patterns to identify state value",
        "5. If pattern matches clearly, extract the state value",
        "6. If no clear pattern found or message is ambiguous, use specified default value (e.g., 'OFF' for debug mode)",
        "7. If message is missing or no response received, use specified default value"
      ],
      "patternMatching": {
        "debugMode": {
          "onPatterns": ["Debug mode: ON", "debug on", "enable debug", "debug enabled", "debugging is on"],
          "offPatterns": ["Debug mode: OFF", "debug off", "disable debug", "debug disabled", "debugging is off"],
          "default": "OFF",
          "example": "Response message: 'State response: Current debugMode value is Debug mode: ON' → Extract: ON"
        },
        "generalStateValue": {
          "process": "Identify field name and value in natural language response",
          "example": "Response: 'State response: Current productName value is \"service-mesh-simulator\"' → Extract: service-mesh-simulator",
          "default": "null (if field not found or value is null)"
        }
      },
      "keywords": {
        "stateIndicators": ["State response", "Current", "value is", "status", "state"],
        "fieldNames": ["productName", "debugMode", "overallConfidence", "satisfied", "ready"],
        "valueIndicators": ["ON", "OFF", "true", "false", "null", "string values in quotes"]
      },
      "semanticUnderstanding": {
        "description": "LLMs use natural language understanding to identify state values, not pattern matching alone",
        "approach": "Understand message intent semantically - what is the message trying to communicate?",
        "flexibility": "Allows for variations in message phrasing while still extracting correct state value"
      },
      "errorHandling": {
        "noResponse": "If no state response message found in context, use default value",
        "ambiguousResponse": "If response is unclear or contradictory, use default value and optionally log warning",
        "missingField": "If requested field is not present in response, use default value (typically null)"
      },
      "reference": "Extends ex:MessageStateManagement semantic filtering for specific state response parsing. This protocol provides explicit steps for parsing state values from natural language state response messages.",
      "usage": "When personas receive state response messages, they should follow this protocol to extract state values using semantic filtering rather than exact string matching."
    },
    {
      "@id": "ex:StateMessageProtocol",
      "@type": "Protocol",
      "purpose": "Protocol for state request, update, and response messages between personas and state management personas",
      "stateRequestMessage": {
        "format": "State request message to state management persona",
        "structure": {
          "type": "state_request",
          "target": "state management persona id (e.g., ex:ProductNameStatePersona)",
          "field": "field name to request (e.g., 'productName', 'debugMode', 'overallConfidence')",
          "naturalLanguage": "Natural language request: 'Please provide current [field] value' or 'What is the current [field]?'"
        },
        "example": "Send message to ex:ProductNameStatePersona: 'State request: What is the current productName value?'"
      },
      "stateUpdateMessage": {
        "format": "State update message to state management persona",
        "structure": {
          "type": "state_update",
          "target": "state management persona id (e.g., ex:ProductNameStatePersona)",
          "field": "field name to update (e.g., 'productName', 'debugMode', 'discussionMode.satisfied')",
          "value": "new value for the field",
          "naturalLanguage": "Natural language update: 'Please update [field] to [value]' or 'Set [field] = [value]'"
        },
        "example": "Send message to ex:ProductNameStatePersona: 'State update: Please set productName to \"service-mesh-simulator\"'"
      },
      "stateResponseMessage": {
        "format": "State response message from state management persona",
        "structure": {
          "type": "state_response",
          "source": "state management persona id",
          "field": "field name that was requested",
          "value": "current value of the field",
          "naturalLanguage": "Natural language response: 'Current [field] value is [value]' or '[field] = [value]'"
        },
        "example": "Response from ex:ProductNameStatePersona: 'State response: Current productName value is \"service-mesh-simulator\"'"
      },
      "usage": "All personas must use state messages to access state. No direct state access is allowed. State management personas respond to state requests and process state updates. Follow ex:SemanticFilteringProtocol (read complete protocol definition and execute all steps) when parsing state response messages.",
      "reference": "This protocol enables persona-encapsulated state management pattern where state is managed by dedicated state management personas rather than shared global state.",
      "stateUpdateParsing": {
        "purpose": "Instructions for state management personas to parse state update messages",
        "process": [
          "1. Receive state update message in context window (message is automatically included in LLM context)",
          "2. Identify message type: 'state_update' or natural language indicators ('State update:', 'Please set', 'Please update', 'Set')",
          "3. Extract field name from message (e.g., 'productName', 'debugMode', 'discussionMode.satisfied')",
          "4. Extract value from message (e.g., 'service-mesh-simulator', 'ON', 'true', 'false')",
          "5. For nested fields (e.g., 'discussionMode.satisfied'), parse dot notation: first part is object name, second part is field name",
          "6. For object updates (e.g., 'requirementAspects'), parse natural language description of object structure or extract structured data",
          "7. Validate field name exists in persona's state schema",
          "8. Validate value type matches expected type (string, number, boolean, object)",
          "9. If validation fails, respond with error message: 'State update error: [reason]'",
          "10. If validation passes, update state in internal isolated context",
          "11. Respond with confirmation: 'State updated: [field] = [value]'"
        ],
        "nestedFieldParsing": {
          "example": "State update: Please set discussionMode.satisfied=true",
          "process": "Parse 'discussionMode.satisfied' as: object='discussionMode', field='satisfied', value='true'",
          "update": "Update discussionMode object's satisfied field to true"
        },
        "objectUpdateParsing": {
          "example": "State update: Please update requirementAspects with {productType: 0.8, coreFunctionality: 0.7, constraints: 0.6, edgeCases: 0.5}",
          "process": "Parse object structure from natural language or structured format, update requirementAspects object",
          "note": "For complex objects, accept natural language descriptions or structured data formats"
        },
        "validation": {
          "fieldExists": "Verify requested field exists in persona's state schema",
          "typeMatch": "Verify value type matches expected type for that field",
          "rangeCheck": "For numeric values, verify within valid range (e.g., confidence scores 0.0-1.0)",
          "formatCheck": "For string values, verify format constraints (e.g., filesystem-safe identifiers)"
        },
        "errorResponses": {
          "invalidField": "State update error: Field '[field]' does not exist in state schema",
          "typeMismatch": "State update error: Value type does not match expected type for field '[field]'",
          "invalidValue": "State update error: Value '[value]' is invalid for field '[field]' (reason: [reason])",
          "parseError": "State update error: Could not parse update message. Expected format: 'State update: Please set [field] = [value]'"
        }
      }
    },
    {
      "@id": "ex:UserQuestionProtocol",
      "@type": "Protocol",
      "purpose": "Protocol for when personas ask questions to users",
      "appliesTo": [
        "Decision escalation questions",
        "Approval requests",
        "Architectural decisions needing user input",
        "Clarification questions",
        "Any question requiring user response"
      ],
      "requiredSteps": [
        "1. Present question clearly to user",
        "2. Set waitingForUserResponse = true in persona's isolated context",
        "3. Set pendingQuestion = [question text] in persona's isolated context",
        "4. STOP all processing immediately",
        "5. DO NOT execute any commands or take any actions",
        "6. Wait for user's explicit response",
        "7. Only after receiving user response, set waitingForUserResponse = false and proceed"
      ],
      "prohibitedWhileWaiting": [
        "Executing system commands (date, file operations, etc.)",
        "Logging decisions",
        "Making assumptions about user's answer",
        "Proceeding with workflow steps",
        "Taking any action other than waiting"
      ],
      "resumptionCheck": {
        "beforeAnyAction": "ALWAYS check waitingForUserResponse in isolated context",
        "ifTrue": "DO NOT take action - you are waiting for user response",
        "ifFalse": "Proceed with normal processing"
      },
      "note": "When asking user a question, you MUST wait for their response. No commands, no assumptions, no proceeding until user answers. This protocol ensures personas properly handle user interaction blocking."
    }
  ]
}

